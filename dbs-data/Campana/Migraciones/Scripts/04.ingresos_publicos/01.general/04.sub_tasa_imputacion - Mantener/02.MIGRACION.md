# 0) (Sólo la primera vez) – Conectar `laramie_ingresos_publicos` ⇄ `laramie_administracion` vía FDW

> Ejecutar en **laramie\_ingresos\_publicos**. Si está hecho, saltar a la sección 1.

```sql
CREATE EXTENSION IF NOT EXISTS postgres_fdw;

DROP SERVER IF EXISTS admin_srv CASCADE;
CREATE SERVER admin_srv
  FOREIGN DATA WRAPPER postgres_fdw
  OPTIONS (host '127.0.0.1', dbname 'laramie_administracion', port '5432');

CREATE USER MAPPING IF NOT EXISTS FOR CURRENT_USER
  SERVER admin_srv
  OPTIONS (user 'postgres', password 'postgres');

CREATE SCHEMA IF NOT EXISTS adm_fdw;

IMPORT FOREIGN SCHEMA public
  LIMIT TO (recurso_por_rubro, jurisdiccion, cuenta_contable)
  FROM SERVER admin_srv INTO adm_fdw;
```

---

# 1) Staging

Si no existe, crear el esquema y la tabla donde se carga el CSV del cliente, tabla Rentas.dbo.tes_asociacionRafam

```sql
CREATE SCHEMA IF NOT EXISTS staging;

-- Tabla staging (si ya existe y se va a recargar, TRUNCATE antes)
CREATE TABLE IF NOT EXISTS staging.tes_asociacionrafam (
  tasa              integer,
  subtasa           integer,
  tipo              varchar(10),
  ejercicioactual   boolean,
  jurisdiccion      varchar(32),
  tiporecaudacion   varchar(10),
  tiporafam         varchar(10),
  clase             varchar(10),
  concepto          varchar(10),
  subconcepto       varchar(10),
  codigoaxt         varchar(64),
  descripcion       varchar(500),
  formadepago       varchar(16)
);
```

Cargar los datos (COPY o GUI).

---

# 2) Vista de normalización (clave: reglas de **subtasa** y del **recurso**)

> Mantiene **los mismos nombres de columnas** para evitar errores de reemplazo.

```sql
CREATE OR REPLACE VIEW staging.v_asociacion_norm AS
SELECT
  a.*,
  NULLIF(UPPER(BTRIM(a.tipo)), '') AS tipo_norm,

  -- SUBTASA: sin padding. Si hay tipo: subtasa||tipo; si no, solo subtasa.
  CASE
    WHEN NULLIF(BTRIM(a.tipo), '') IS NULL
      THEN a.subtasa::text
    ELSE a.subtasa::text || UPPER(BTRIM(a.tipo))
  END AS subtasa_codigo_laramie,

  -- Recurso (compacto: 12 + clase + 05 + 01 => 1210501)
  REGEXP_REPLACE(COALESCE(a.tiporafam,''), '\D', '', 'g')
  || REGEXP_REPLACE(COALESCE(a.clase,''),   '\D', '', 'g')
  || LPAD(REGEXP_REPLACE(COALESCE(a.concepto,''),   '\D', '', 'g'), 2, '0')
  || LPAD(REGEXP_REPLACE(COALESCE(a.subconcepto,''),'\D', '', 'g'), 2, '0')
  AS recurso_rubro_8d,

  -- Recurso (dotted RAFAM correcto: 1.2.1.05.01)
  (CASE
     WHEN LENGTH(REGEXP_REPLACE(COALESCE(a.tiporafam,''),'\D','','g')) = 2
       THEN SUBSTRING(REGEXP_REPLACE(COALESCE(a.tiporafam,''),'\D','','g') FROM 1 FOR 1)
            || '.' ||
            SUBSTRING(REGEXP_REPLACE(COALESCE(a.tiporafam,''),'\D','','g') FROM 2 FOR 1)
     ELSE REGEXP_REPLACE(COALESCE(a.tiporafam,''),'\D','','g')
   END) || '.' ||
   REGEXP_REPLACE(COALESCE(a.clase,''),'\D','','g') || '.' ||
   LPAD(REGEXP_REPLACE(COALESCE(a.concepto,''),'\D','','g'),2,'0') || '.' ||
   LPAD(REGEXP_REPLACE(COALESCE(a.subconcepto,''),'\D','','g'),2,'0')
  AS recurso_rubro_dotted,

  -- Jurisdicción: sin puntos
  BTRIM(a.jurisdiccion) AS jurisdiccion_sinpuntos
FROM staging.tes_asociacionrafam a;
```

---

# 3) Vistas de mapeo mínimas (tasa y subtasa)

```sql
CREATE OR REPLACE VIEW staging.v_tasa_map AS
SELECT t.id AS id_tasa, t.codigo::text AS codigo_tasa
FROM public.tasa t;

CREATE OR REPLACE VIEW staging.v_subtasa_map AS
SELECT s.id AS id_subtasa, s.id_tasa, s.codigo::text AS codigo_subtasa
FROM public.sub_tasa s;
```

> Asegurar que `public.sub_tasa.codigo` siga la regla `subtasa||tipo` (sin ceros delante).

---

# 4) (Opcional) Puente manual para recursos “especiales”

```sql
CREATE TABLE IF NOT EXISTS staging.recurso_map_manual (
  recurso_rubro_8d      varchar(8) PRIMARY KEY,   -- clave = formato compacto (p.ej. 1210501)
  id_recurso_por_rubro  bigint NOT NULL           -- apunta a adm_fdw.recurso_por_rubro.id
);
```

---

# 5) Idempotencia en destino

La tabla destino ya existe (`public.sub_tasa_imputacion`). Creamos índice único:

```sql
CREATE UNIQUE INDEX IF NOT EXISTS ux_sub_tasa_imputacion_key
ON public.sub_tasa_imputacion (id_tasa, id_sub_tasa, ejercicio);
```

---

# 6) QA rápida (opcional pero recomendada)

```sql
-- Tasa/Subtasa que no mapean (probable problema en public.sub_tasa.codigo)
WITH src AS (
  SELECT * FROM staging.v_asociacion_norm WHERE ejercicioactual IS TRUE
)
SELECT DISTINCT s.tasa, s.subtasa, s.tipo_norm, s.subtasa_codigo_laramie
FROM src s
LEFT JOIN staging.v_tasa_map    tm ON tm.codigo_tasa = s.tasa::text
LEFT JOIN staging.v_subtasa_map sm ON sm.codigo_subtasa = s.subtasa_codigo_laramie
                                   AND sm.id_tasa      = tm.id_tasa
WHERE tm.id_tasa IS NULL OR sm.id_subtasa IS NULL
ORDER BY 1,2,3
LIMIT 50;

-- Recursos (formato nuevo) que no mapean ni por compact ni por dotted
WITH src AS (
  SELECT * FROM staging.v_asociacion_norm WHERE ejercicioactual IS TRUE
)
SELECT DISTINCT s.recurso_rubro_8d AS compact, s.recurso_rubro_dotted AS dotted
FROM src s
LEFT JOIN adm_fdw.recurso_por_rubro rr
  ON REPLACE(rr.codigo::text,'.','') = s.recurso_rubro_8d
  OR rr.codigo::text                 = s.recurso_rubro_dotted
WHERE rr.id IS NULL
ORDER BY 1
LIMIT 50;
```

Si algo aparece acá, corregir antes o cargar en `staging.recurso_map_manual`.

---

# 7) UPSERT **ACTUAL** (elige jurisdicción/recurso/cuenta del **2025** con fallback razonable)

```sql
BEGIN;

WITH params AS (
  SELECT '2025'::varchar(20) AS ejercicio_txt,
         2025::int           AS ejercicio_int,
         1270::bigint        AS id_tipo_cuota
),
src AS (
  SELECT *
  FROM staging.v_asociacion_norm
  WHERE ejercicioactual IS TRUE
),
codes AS (
  SELECT DISTINCT
         s.jurisdiccion_sinpuntos,
         s.recurso_rubro_8d,       -- compacto 1210501
         s.recurso_rubro_dotted,   -- dotted 1.2.1.05.01
         NULLIF(s.codigoaxt,'') AS codigoaxt
  FROM src s
),
-- Jurisdicción: pick por año 2025 con fallback (igual -> anterior -> posterior)
jur_candidates AS (
  SELECT
    c.jurisdiccion_sinpuntos,
    j.id,
    j.ejercicio::int AS ej,
    j.fecha_baja,
    j.nivel,
    ROW_NUMBER() OVER (
      PARTITION BY c.jurisdiccion_sinpuntos
      ORDER BY
        CASE
          WHEN j.ejercicio::int = p.ejercicio_int THEN 0
          WHEN j.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(j.ejercicio::int - p.ejercicio_int),
        (j.fecha_baja IS NULL) DESC,
        j.nivel DESC,
        j.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.jurisdiccion j
       ON REPLACE(j.codigo::text,'.','') = c.jurisdiccion_sinpuntos
),
jur_pick AS (
  SELECT jurisdiccion_sinpuntos, id AS id_jurisdiccion
  FROM jur_candidates
  WHERE rn = 1
),
-- Recurso: prueba compact y dotted, mismo ranking por año
rr_candidates AS (
  SELECT
    c.recurso_rubro_8d,
    c.recurso_rubro_dotted,
    rr.id,
    rr.ejercicio::int AS ej,
    rr.fecha_baja,
    rr.nivel,
    ROW_NUMBER() OVER (
      PARTITION BY c.recurso_rubro_8d, c.recurso_rubro_dotted
      ORDER BY
        CASE
          WHEN rr.ejercicio::int = p.ejercicio_int THEN 0
          WHEN rr.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(rr.ejercicio::int - p.ejercicio_int),
        (rr.fecha_baja IS NULL) DESC,
        rr.nivel DESC,
        rr.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.recurso_por_rubro rr
       ON REPLACE(rr.codigo::text,'.','') = c.recurso_rubro_8d
       OR rr.codigo::text                 = c.recurso_rubro_dotted
),
rr_pick_base AS (
  SELECT recurso_rubro_8d, recurso_rubro_dotted, id AS id_recurso
  FROM rr_candidates
  WHERE rn = 1
),
-- Prioriza manual si existe
rr_pick AS (
  SELECT
    b.recurso_rubro_8d,
    b.recurso_rubro_dotted,
    COALESCE(m.id_recurso_por_rubro, b.id_recurso) AS id_recurso
  FROM rr_pick_base b
  LEFT JOIN staging.recurso_map_manual m
         ON m.recurso_rubro_8d = b.recurso_rubro_8d
),
-- Cuenta contable: pick por 2025 con fallback
cc_candidates AS (
  SELECT
    c.codigoaxt,
    cc.id,
    cc.ejercicio::int AS ej,
    cc.fecha_baja,
    ROW_NUMBER() OVER (
      PARTITION BY c.codigoaxt
      ORDER BY
        CASE
          WHEN cc.ejercicio::int = p.ejercicio_int THEN 0
          WHEN cc.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(cc.ejercicio::int - p.ejercicio_int),
        (cc.fecha_baja IS NULL) DESC,
        cc.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.cuenta_contable cc
       ON cc.codigo::text = c.codigoaxt
  WHERE c.codigoaxt IS NOT NULL
),
cc_pick AS (
  SELECT codigoaxt, id AS id_cuenta
  FROM cc_candidates
  WHERE rn = 1
),
-- Enlazado final por fila del staging
enlazado AS (
  SELECT
    tm.id_tasa,
    sm.id_subtasa,
    jp.id_jurisdiccion,
    rp.id_recurso,
    cp.id_cuenta,
    s.formadepago::varchar(50)     AS forma_pago,
    s.tiporecaudacion::varchar(50) AS tipo_recaudacion
  FROM src s
  JOIN staging.v_tasa_map    tm ON tm.codigo_tasa = s.tasa::text
  JOIN staging.v_subtasa_map sm ON sm.codigo_subtasa = s.subtasa_codigo_laramie
                                AND sm.id_tasa      = tm.id_tasa
  LEFT JOIN jur_pick jp ON jp.jurisdiccion_sinpuntos = s.jurisdiccion_sinpuntos
  LEFT JOIN rr_pick  rp ON rp.recurso_rubro_8d       = s.recurso_rubro_8d
                        AND rp.recurso_rubro_dotted  = s.recurso_rubro_dotted
  LEFT JOIN cc_pick  cp ON cp.codigoaxt              = NULLIF(s.codigoaxt,'')
),
-- 1 fila por (tasa, subtasa)
rollup AS (
  SELECT
    id_tasa,
    id_subtasa,
    MIN(id_jurisdiccion) AS id_jurisdiccion,
    MIN(id_recurso)      AS id_recurso,
    MIN(id_cuenta)       AS id_cuenta,
    MIN(forma_pago)      AS forma_pago,
    MIN(tipo_recaudacion) AS tipo_recaudacion
  FROM enlazado
  WHERE id_jurisdiccion IS NOT NULL
    AND id_recurso      IS NOT NULL
  GROUP BY id_tasa, id_subtasa
)

INSERT INTO public.sub_tasa_imputacion (
  id_tasa,
  id_sub_tasa,
  ejercicio,
  id_tipo_cuota,
  id_cuenta_contable,
  id_jurisdiccion_actual,
  id_recurso_por_rubro_actual,
  codigo_forma_pago,
  codigo_tipo_recaudacion
)
SELECT
  r.id_tasa,
  r.id_subtasa,
  p.ejercicio_txt,
  p.id_tipo_cuota,
  r.id_cuenta,
  r.id_jurisdiccion,
  r.id_recurso,
  r.forma_pago,
  r.tipo_recaudacion
FROM rollup r
CROSS JOIN params p
ON CONFLICT (id_tasa, id_sub_tasa, ejercicio)
DO UPDATE SET
  id_tipo_cuota               = EXCLUDED.id_tipo_cuota,
  id_cuenta_contable          = COALESCE(EXCLUDED.id_cuenta_contable, public.sub_tasa_imputacion.id_cuenta_contable),
  id_jurisdiccion_actual      = COALESCE(EXCLUDED.id_jurisdiccion_actual, public.sub_tasa_imputacion.id_jurisdiccion_actual),
  id_recurso_por_rubro_actual = COALESCE(EXCLUDED.id_recurso_por_rubro_actual, public.sub_tasa_imputacion.id_recurso_por_rubro_actual),
  codigo_forma_pago           = COALESCE(public.sub_tasa_imputacion.codigo_forma_pago, EXCLUDED.codigo_forma_pago),
  codigo_tipo_recaudacion     = COALESCE(public.sub_tasa_imputacion.codigo_tipo_recaudacion, EXCLUDED.codigo_tipo_recaudacion);

COMMIT;
```

---

# 8) UPSERT **ANTERIOR** (elige jurisdicción/recurso/cuenta del **2024** con el mismo criterio)

```sql
BEGIN;

WITH params AS (
  SELECT '2025'::varchar(20) AS ejercicio_txt,  -- cargamos ejercicio 2025 en destino
         2024::int           AS ejercicio_int,  -- pero pickeamos 2024 en maestros
         1270::bigint        AS id_tipo_cuota
),
src AS (
  SELECT *
  FROM staging.v_asociacion_norm
  WHERE ejercicioactual IS FALSE
),
codes AS (
  SELECT DISTINCT
         s.jurisdiccion_sinpuntos,
         s.recurso_rubro_8d,
         s.recurso_rubro_dotted,
         NULLIF(s.codigoaxt,'') AS codigoaxt
  FROM src s
),
jur_candidates AS (
  SELECT
    c.jurisdiccion_sinpuntos,
    j.id,
    j.ejercicio::int AS ej,
    j.fecha_baja,
    j.nivel,
    ROW_NUMBER() OVER (
      PARTITION BY c.jurisdiccion_sinpuntos
      ORDER BY
        CASE
          WHEN j.ejercicio::int = p.ejercicio_int THEN 0
          WHEN j.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(j.ejercicio::int - p.ejercicio_int),
        (j.fecha_baja IS NULL) DESC,
        j.nivel DESC,
        j.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.jurisdiccion j
       ON REPLACE(j.codigo::text,'.','') = c.jurisdiccion_sinpuntos
),
jur_pick AS (
  SELECT jurisdiccion_sinpuntos, id AS id_jurisdiccion
  FROM jur_candidates
  WHERE rn = 1
),
rr_candidates AS (
  SELECT
    c.recurso_rubro_8d,
    c.recurso_rubro_dotted,
    rr.id,
    rr.ejercicio::int AS ej,
    rr.fecha_baja,
    rr.nivel,
    ROW_NUMBER() OVER (
      PARTITION BY c.recurso_rubro_8d, c.recurso_rubro_dotted
      ORDER BY
        CASE
          WHEN rr.ejercicio::int = p.ejercicio_int THEN 0
          WHEN rr.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(rr.ejercicio::int - p.ejercicio_int),
        (rr.fecha_baja IS NULL) DESC,
        rr.nivel DESC,
        rr.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.recurso_por_rubro rr
       ON REPLACE(rr.codigo::text,'.','') = c.recurso_rubro_8d
       OR rr.codigo::text                 = c.recurso_rubro_dotted
),
rr_pick_base AS (
  SELECT recurso_rubro_8d, recurso_rubro_dotted, id AS id_recurso
  FROM rr_candidates
  WHERE rn = 1
),
rr_pick AS (
  SELECT
    b.recurso_rubro_8d,
    b.recurso_rubro_dotted,
    COALESCE(m.id_recurso_por_rubro, b.id_recurso) AS id_recurso
  FROM rr_pick_base b
  LEFT JOIN staging.recurso_map_manual m
         ON m.recurso_rubro_8d = b.recurso_rubro_8d
),
cc_candidates AS (
  SELECT
    c.codigoaxt,
    cc.id,
    cc.ejercicio::int AS ej,
    cc.fecha_baja,
    ROW_NUMBER() OVER (
      PARTITION BY c.codigoaxt
      ORDER BY
        CASE
          WHEN cc.ejercicio::int = p.ejercicio_int THEN 0
          WHEN cc.ejercicio::int < p.ejercicio_int THEN 1
          ELSE 2
        END,
        ABS(cc.ejercicio::int - p.ejercicio_int),
        (cc.fecha_baja IS NULL) DESC,
        cc.id DESC
    ) AS rn
  FROM codes c
  CROSS JOIN params p
  JOIN adm_fdw.cuenta_contable cc
       ON cc.codigo::text = c.codigoaxt
  WHERE c.codigoaxt IS NOT NULL
),
cc_pick AS (
  SELECT codigoaxt, id AS id_cuenta
  FROM cc_candidates
  WHERE rn = 1
),
enlazado AS (
  SELECT
    tm.id_tasa,
    sm.id_subtasa,
    jp.id_jurisdiccion,
    rp.id_recurso,
    cp.id_cuenta,
    s.formadepago::varchar(50)     AS forma_pago,
    s.tiporecaudacion::varchar(50) AS tipo_recaudacion
  FROM src s
  JOIN staging.v_tasa_map    tm ON tm.codigo_tasa = s.tasa::text
  JOIN staging.v_subtasa_map sm ON sm.codigo_subtasa = s.subtasa_codigo_laramie
                                AND sm.id_tasa      = tm.id_tasa
  LEFT JOIN jur_pick jp ON jp.jurisdiccion_sinpuntos = s.jurisdiccion_sinpuntos
  LEFT JOIN rr_pick  rp ON rp.recurso_rubro_8d       = s.recurso_rubro_8d
                        AND rp.recurso_rubro_dotted  = s.recurso_rubro_dotted
  LEFT JOIN cc_pick  cp ON cp.codigoaxt              = NULLIF(s.codigoaxt,'')
),
rollup AS (
  SELECT
    id_tasa,
    id_subtasa,
    MIN(id_jurisdiccion) AS id_jurisdiccion,
    MIN(id_recurso)      AS id_recurso,
    MIN(id_cuenta)       AS id_cuenta,
    MIN(forma_pago)      AS forma_pago,
    MIN(tipo_recaudacion) AS tipo_recaudacion
  FROM enlazado
  WHERE id_jurisdiccion IS NOT NULL
    AND id_recurso      IS NOT NULL
  GROUP BY id_tasa, id_subtasa
)

INSERT INTO public.sub_tasa_imputacion (
  id_tasa,
  id_sub_tasa,
  ejercicio,
  id_tipo_cuota,
  id_cuenta_contable_anterior,
  id_jurisdiccion_anterior,
  id_recurso_por_rubro_anterior,
  codigo_forma_pago,
  codigo_tipo_recaudacion
)
SELECT
  r.id_tasa,
  r.id_subtasa,
  p.ejercicio_txt,
  p.id_tipo_cuota,
  r.id_cuenta,
  r.id_jurisdiccion,
  r.id_recurso,
  r.forma_pago,
  r.tipo_recaudacion
FROM rollup r
CROSS JOIN params p
ON CONFLICT (id_tasa, id_sub_tasa, ejercicio)
DO UPDATE SET
  id_tipo_cuota                    = EXCLUDED.id_tipo_cuota,
  id_cuenta_contable_anterior      = COALESCE(EXCLUDED.id_cuenta_contable_anterior, public.sub_tasa_imputacion.id_cuenta_contable_anterior),
  id_jurisdiccion_anterior         = COALESCE(EXCLUDED.id_jurisdiccion_anterior, public.sub_tasa_imputacion.id_jurisdiccion_anterior),
  id_recurso_por_rubro_anterior    = COALESCE(EXCLUDED.id_recurso_por_rubro_anterior, public.sub_tasa_imputacion.id_recurso_por_rubro_anterior),
  codigo_forma_pago                = COALESCE(public.sub_tasa_imputacion.codigo_forma_pago, EXCLUDED.codigo_forma_pago),
  codigo_tipo_recaudacion          = COALESCE(public.sub_tasa_imputacion.codigo_tipo_recaudacion, EXCLUDED.codigo_tipo_recaudacion);

COMMIT;
```

---

# 9) Auditoría rápida post-carga (opcional)

```sql
-- Cantidad de filas por tasa/subtasa cargadas para 2025
SELECT id_tasa, id_sub_tasa,
       COUNT(*) AS filas
FROM public.sub_tasa_imputacion
WHERE ejercicio = '2025'
GROUP BY 1,2
ORDER BY 1,2;

-- Muestra 10 filas con los IDs seteados
SELECT id_tasa, id_sub_tasa, ejercicio,
       id_cuenta_contable,
       id_jurisdiccion_actual, id_recurso_por_rubro_actual,
       id_cuenta_contable_anterior,
       id_jurisdiccion_anterior, id_recurso_por_rubro_anterior,
       codigo_forma_pago, codigo_tipo_recaudacion
FROM public.sub_tasa_imputacion
WHERE ejercicio = '2025'
ORDER BY id_tasa, id_sub_tasa
LIMIT 10;
```

---

## Tips finales

* Si se necesita re-correr todo: **volver a cargar staging (si cambió), recrear la vista (paso 2)** y correr los **dos UPSERT** (7 y 8). Son idempotentes por el índice único.
* Si algún recurso no aparece en el maestro con esos códigos, cargarlo en `staging.recurso_map_manual` y re-ejecutar el UPSERT correspondiente (entra solo).
* Si alguna `sub_tasa` no mapea, revisar `public.sub_tasa.codigo` para esa tasa/subtasa/tipo con la regla que definimos (sin ceros, sin padding).
